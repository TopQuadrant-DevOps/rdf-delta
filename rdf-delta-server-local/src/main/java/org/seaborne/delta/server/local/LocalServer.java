/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.seaborne.delta.server.local;

import static org.seaborne.delta.DPNames.F_BASE;
import static org.seaborne.delta.DPNames.F_ID;
import static org.seaborne.delta.DPNames.F_PORT;
import static org.seaborne.delta.DPNames.F_URI;
import static org.seaborne.delta.DPNames.F_VERSION;
import static org.seaborne.delta.DPNames.PORT;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.jena.atlas.io.IO;
import org.apache.jena.atlas.json.JSON;
import org.apache.jena.atlas.json.JsonBuilder;
import org.apache.jena.atlas.json.JsonObject;
import org.apache.jena.atlas.lib.FileOps;
import org.apache.jena.atlas.logging.FmtLog;
import org.apache.jena.sparql.core.DatasetGraph;
import org.apache.jena.sparql.core.DatasetGraphFactory;
import org.apache.jena.tdb.TDBFactory;
import org.apache.jena.tdb.base.file.Location;
import org.seaborne.delta.DPNames;
import org.seaborne.delta.DeltaConfigException;
import org.seaborne.delta.DeltaException;
import org.seaborne.delta.Id;
import org.seaborne.delta.lib.JSONX;
import org.seaborne.delta.lib.LibX;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** A local server.
 *  <p>
 *  This provides for several {@link DataSource} areas (one per managed patch set - i.e. one per dataset).
 *  {@code LocalServer} is responsible for server wide configuration and for the 
 *  {@link DataSource} lifecycle of create and delete.  
 *    
 * @see DeltaLinkLocal 
 * @see DataSource 
 *
 */
public class LocalServer {
    /* File system layout:
     *   Server Root
     *      source.cfg
     *      datasources.cfg
     *      /NAME ... per DataSource.
     *          autogenerated assembler?
     *          /patches
     *          /database -- TDB database (if not in-memory)
     *          
     *  But also external databases 
     */
    
    private static Logger LOG = LoggerFactory.getLogger(LocalServer.class);
    private static final int SYSTEM_VERSION = 1; 

    private final DataRegistry dataRegistry;
    private final Location serverRoot;
    private final String configFile;
    
    
    // Key configuration items
    //private final int port;
    
    /** Attach to the runtime area for the server. Use "delta.cfg" as the configuration file name.  
     * @param serverRoot
     * @return LocalServer
     */
    public static LocalServer attach(Location serverRoot) {
        return attach(serverRoot, DPNames.SERVER_CONFIG); 
    }
    
    /** Attach to the runtime area for the server.
     * @param serverRoot
     * @param confFile  Filename: absolute filename, or relative to the server process.
     * @return LocalServer
     */
    public static LocalServer attach(Location serverRoot, String confFile) {
        //DataRegistry dataRegistry = DataRegistry.get();
        DataRegistry dataRegistry = new DataRegistry("Server");
        
        // ---- Configuration file.
        
        String cfgfn = LibX.resolve(serverRoot, confFile);
        //LOG.info("Server config file: "+cfgfn);
        
        InputStream in = IO.openFile(cfgfn);
        if ( in == null ) {
            LOG.warn("No source configuration" );
        }
        
        JsonObject rootObj = JSON.parse(in) ;
        // Top level object:
        // {  "port"    : ...,
        //    "sources" : [ ... ]
        //    "version"  -- unused, must be 1
        // }
        int version = JSONX.getInt(rootObj, F_VERSION, -99);
        if ( version == -99 ) {
            LOG.warn("No version number for the configuration file : assuming 'current'");
            version = SYSTEM_VERSION;
        }
        if ( version != SYSTEM_VERSION )
            throw new DeltaConfigException("Version number for LocalServer must be "+SYSTEM_VERSION+".");
        
        int port = JSONX.getInt(rootObj, F_PORT, -1);
        if ( port <= 0  ) {
            LOG.info("No port number: Using default "+DPNames.PORT);
            port = PORT;
        }

        // ---- Configuration file.
        
        //"sources" - array of directories names to look for data sources.
//        List<String> directoryNames = new ArrayList<>();
//        JsonValue jv = rootObj.get(F_SOURCES);
//        if ( jv == null )
//            LOG.info("Only scanning server configuration area for data sources");
        
        List<Path> dataSources = scanDirectory(serverRoot, dataRegistry);
        //dataSources.stream().forEach(p->LOG.info("Data source: "+p));
        
        for ( Path p : dataSources ) {
            DataSource ds = makeDataSource(p);
            dataRegistry.put(ds.getId(), ds);
        }
        return new LocalServer(serverRoot, confFile, dataRegistry);
    }       
     
    
    /** Scan a directory for datasource areas.
     * These must have a file called   
     */
    private static List<Path> scanDirectory(Location serverRoot, DataRegistry dataRegistry) {
        Path dir = Paths.get(serverRoot.getDirectoryPath());
        try { 
            return Files.list(dir).filter(LocalServer::isDataSource).collect(Collectors.toList());
        }
        catch (IOException e) {
            LOG.error("Exception while reading "+dir);
            IO.exception(e);
            return null;
        }
    }

    /** Test for a valid data source */
    private static boolean isDataSource(Path path) {
        if ( ! Files.isDirectory(path) ) 
            return false ;
        Path cfg = path.resolve(DPNames.DATA_CONFIG);
        if ( ! Files.exists(cfg) )
            return false ;
        if ( ! Files.isRegularFile(cfg) ) 
            LOG.warn("Data source configuration file name exists but is not a file: "+cfg);
        if ( ! Files.isReadable(cfg) )
            LOG.warn("Data source configuration file exists but is not readable: "+cfg);
        return true ;
    }

    private static DataSource makeDataSource(Path dataSourceArea) {
        JsonObject sourceObj = JSON.read(dataSourceArea.resolve(DPNames.DATA_CONFIG).toString());
        String idStr = JSONX.getStrOrNull(sourceObj, F_ID) ;
        Id id = Id.fromString(idStr) ; 
        String uriStr = JSONX.getStrOrNull(sourceObj, F_URI) ;
        String baseStr = JSONX.getStrOrNull(sourceObj, F_BASE);
      
        Path patchesArea = dataSourceArea.resolve(DPNames.PATCHES);
        //FmtLog.info(LOG, "DataSource: id=%s, source=%s, patches=%s", id, dataSourceArea, patchesArea);
        
        // --> Path
        DataSource dataSource = DataSource.attach(id, uriStr, location(dataSourceArea), location(patchesArea));
        FmtLog.info(LOG, "DataSource: %s (%s)", dataSource, baseStr);
      
        return dataSource ;
    }
    
    // -> IOX
    private static Location location(Path path) {
        return Location.create(path.toString());
    }
    
    // -> IOX
    private static Path path(Location location) {
        return Paths.get(location.getDirectoryPath());
    }

    public LocalServer(Location serverRoot, String confFile, DataRegistry dataRegistry) {
        this.serverRoot = serverRoot;
        this.configFile = confFile;
        this.dataRegistry = dataRegistry;
    }

    public DataRegistry getDataRegistry() {
        return dataRegistry;
    }
    
    public DataSource getDataSource(Id dsRef) {
        return dataRegistry.get(dsRef);
    }

    public List<Id> listDataSourcesIds() {
        return new ArrayList<>(dataRegistry.keys());
    }
    
    // XXX Or access by Id.
    // list Ids.
    public List<DataSource> listDataSources() {
      List<DataSource> x = new ArrayList<>();
      dataRegistry.forEach((id, ds)-> x.add(ds));
      return x;
    }

    // XXX ????
    public SourceDescriptor getDescriptor(Id dsRef) {
        DataSource dataSource = dataRegistry.get(dsRef);
        return descriptor(dataSource);
    }
    
    private SourceDescriptor descriptor(DataSource dataSource) {
        SourceDescriptor descr = new SourceDescriptor
            (dataSource.getId(),
             dataSource.getURI(),
             dataSource.getLocation().getDirectoryPath()); // <<-- XXX make relative.
        return descr;
    }
    
    static class SourceDescriptor {
        final String uri;
        final Id id;
        final String base;
        public SourceDescriptor(Id id, String uri, String base) {
            super();
            this.id = id;
            this.uri = uri;
            this.base = base;
        }
    }
    
    private static Location dataSourceArea(Location serverRoot, String name) {
        return serverRoot.getSubLocation(name);
    }
    
    private static Location patchArea(Location dataSourceArea) {
        return dataSourceArea.getSubLocation(DPNames.PATCHES);
    }

    //public Id addDataSource(String name, String baseURI/*, details*/) {}
    
    // Create the decriptor.
    public Id addDataSource(boolean inMemory, String name, String baseURI/*, details*/) {
        // Check area.
        isDataSource(null);
        makeDataSource(null);
        
        
        return null ;
    }
    
    
//    public Id connect(String name) {
//        
//    }
    
    public Id createDataSource(boolean inMemory, String name, String baseURI/*, details*/) {
        Location sourceArea = dataSourceArea(serverRoot, name);
        
        // Checking.
        // The iretc can exist, but it must not be formatted for a  
//        if ( sourceArea.exists() )
//            throw new DeltaException("Area already exists");

        if ( isDataSource(path(sourceArea) )) {
            throw new DeltaException("DataSource area already exists at: "+sourceArea);
        }
        
        String patchedDirName = sourceArea.getPath(DPNames.PATCHES);
        
        if ( FileOps.exists(patchedDirName) )
            throw new DeltaException("DataSource area does not have a configuration but does have a patches area.");

        String dataDirName = sourceArea.getPath(DPNames.DATA);
        if ( FileOps.exists(dataDirName) )
            throw new DeltaException("DataSource area has a likely looking database already");
        
        // This ensures it exists.
        Location patchesArea = patchArea(sourceArea);
        Location db = sourceArea.getSubLocation(DPNames.DATA);
        
        Id id = Id.create();
        SourceDescriptor descr = new SourceDescriptor(id, baseURI, name);
        
        DatasetGraph dsg;
        if ( inMemory ) {
            FmtLog.info(LOG, "Create in-memory database");
            dsg = DatasetGraphFactory.createTxnMem();
        } else {
            JsonObject obj = toJsonObj(descr);
            LOG.info(JSON.toStringFlat(obj));
            String fn = sourceArea.getPath(DPNames.DATA_CONFIG);
            try (OutputStream out = IO.openOutputFile(fn) ) {
                JSON.write(out, obj);
            } catch (IOException x) {
                IO.exception(x);
            }
            FmtLog.info(LOG, "Create database at %s", db);
            dsg = TDBFactory.createDatasetGraph(db);
        }
        // XXX Database???
        
        
        
        DataSource newDataSource = DataSource.attach(id, baseURI, sourceArea, patchesArea);
        dataRegistry.put(id, newDataSource);
        return id ;
    }
    
    /** SourceDescriptor -> JsonObject */
    private static SourceDescriptor fromJsonObject(JsonObject sourceObj) {
        String idStr = JSONX.getStrOrNull(sourceObj, F_ID);
        
        SourceDescriptor descr = new SourceDescriptor
            (Id.fromString(idStr), 
             JSONX.getStrOrNull(sourceObj, F_URI),
             JSONX.getStrOrNull(sourceObj, F_BASE));
        return descr;
    }
    
    /** JsonObject -> SourceDescriptor */
    private static JsonObject toJsonObj(SourceDescriptor descr) {
        JsonBuilder builder = JsonBuilder.create() ;
        builder.startObject();
        set(builder, F_ID, descr.id.asJsonString());
        set(builder, F_URI, descr.uri);
        set(builder, F_BASE, descr.base);
        builder.finishObject();
        return builder.build().getAsObject();
    }

    /** SourceDescriptor -> JsonObject */
    private static void set(JsonBuilder builder, String field, String value) {
        if ( value != null )
            builder.key(field).value(value);
    }
}
