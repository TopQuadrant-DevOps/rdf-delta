/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.seaborne.delta.server.local;

import static org.seaborne.delta.DPNames.*;
import static org.seaborne.delta.DPNames.F_PORT;
import static org.seaborne.delta.DPNames.F_SOURCES;
import static org.seaborne.delta.DPNames.F_VERSION;
import static org.seaborne.delta.DPNames.PORT;

import java.io.InputStream;
import java.io.OutputStream;

import org.apache.jena.atlas.io.IO;
import org.apache.jena.atlas.json.*;
import org.apache.jena.atlas.logging.FmtLog;
import org.apache.jena.sparql.core.DatasetGraph;
import org.apache.jena.sparql.core.DatasetGraphFactory;
import org.apache.jena.tdb.TDBFactory;
import org.apache.jena.tdb.base.file.Location;
import org.seaborne.delta.DPNames;
import org.seaborne.delta.DeltaConfigException;
import org.seaborne.delta.lib.J;
import org.seaborne.delta.link.Id;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** A local server */
public class LocalServer {
    /* File system layout:
     *   Server Root
     *      source.cfg
     *      /NAME ... per DataSource.
     *          autogenerated assembler?
     *          /patches
     *          /database -- TDB database (if not in-memory)
     *          
     *  But also external databases 
     */
    
    private static Logger LOG = LoggerFactory.getLogger(LocalServer.class);

    private final DataRegistry dataRegistry;
    private final Location serverRoot;
    private final String configFile;
    
    /** Attach to the runtime area for the server.
     * @param serverRoot
     * @param confFile  Filename: absolute filename, or relative to the server process.
     * @return LocalServer
     */
    public static LocalServer attach(Location serverRoot, String confFile) {
        // XXX ?? Per server? Or per "zone"?
        
        DataRegistry dataRegistry = DataRegistry.get();
        
        InputStream in = IO.openFile(confFile);
        if ( in == null ) {
            LOG.warn("No source configuration" );
        }
        
        JsonObject rootObj = JSON.parse(in) ;
        // Top level object:
        // {  "port"    : ...,
        //    "sources" : [ ... ]
        //    "version"  -- unused, must be 1
        // }
        int version = J.getInt(rootObj, F_VERSION, -99);
        if ( version == -99 )
            LOG.warn("No version number for the configruation file : assuming 'current'");
        
        int port = J.getInt(rootObj, F_PORT, -1);
        if ( port <= 0  ) {
            LOG.info("No port number: Using default "+DPNames.PORT);
            port = PORT;
        }
        JsonValue jv = rootObj.get(F_SOURCES);
        if ( ! jv.isArray() )
            throw new DeltaConfigException("Not an array for field \""+F_SOURCES+"\""); 
        JsonArray sources = jv.getAsArray();

        // Sources array of objects:
        // { "basename" -- short name used to find the directory 
        //   "id"       -- the global id.
        //   "name"     -- the URL naming this
        // }
        
        for ( JsonValue v : sources ) {
            JsonObject sourceObj = v.getAsObject();
        
            String idStr = J.getStrOrNull(sourceObj, F_ID) ;
            Id id = Id.fromString(idStr) ; 
            String uriStr = J.getStrOrNull(sourceObj, F_URI) ;
            String baseStr = J.getStrOrNull(sourceObj, F_BASE);
            Location dataSourceArea = dataSourceArea(serverRoot,baseStr);
            
            if ( ! dataSourceArea.exists() )
                throw new DeltaConfigException("No such directory: "+dataSourceArea);
            
            Location patchesArea = patchArea(dataSourceArea);
            FmtLog.info(LOG, "DataSource: id=%s, source=%s, patches=%s", id, dataSourceArea, patchesArea);
            DataSource dataSource = DataSource.attach(id, uriStr, dataSourceArea, patchesArea);
            FmtLog.info(LOG, "DataSource: %s (%s)", dataSource, baseStr);
            
            DataRegistry.get().put(id, dataSource);
        }
        
        return new LocalServer(serverRoot, confFile, dataRegistry);
    }
    
    public LocalServer(Location serverRoot, String confFile, DataRegistry dataRegistry) {
        this.serverRoot = serverRoot;
        this.configFile = confFile;
        this.dataRegistry = dataRegistry;
    }

    public DataRegistry getDataRegistry() {
        return dataRegistry;
    }
    
    static class SourceDescriptor {
        String base;
        String idStr;
        Id id;
        String name;
    }
    
    private static Location dataSourceArea(Location serverRoot, String name) {
        return serverRoot.getSubLocation(name);
    }
    
    private static Location patchArea(Location dataSourceArea) {
        return dataSourceArea.getSubLocation(DPNames.PATCHES);
    }

    public Id createDatabase(boolean inMemory, String name, String baseURI/*, details*/) {
//        String idStr = J.getStrOrNull(sourceObj, F_ID) ;
//        Id id = Id.fromString(idStr) ; 
//        String uriStr = J.getStrOrNull(sourceObj, F_URI) ;
//        String baseStr = J.getStrOrNull(sourceObj, F_BASE);
        
        SourceDescriptor descr = new SourceDescriptor();
        Id id = Id.create();
        descr.id = id; 
        descr.idStr = id.asString();
        descr.name = name;
        descr.base = baseURI;

        Location sourceArea = dataSourceArea(serverRoot, name);
        Location patchesArea = patchArea(sourceArea);

        DatasetGraph dsg;
        if ( inMemory ) {
            FmtLog.info(LOG, "Create in-memory database");
            dsg = DatasetGraphFactory.createTxnMem();
        } else {
            // XXX Write config.
            String fn = sourceArea.getPath(")  
            try (OutputStream out = IO.openOutputFile(name) 
            ************
            Location db = sourceArea.getSubLocation("data");
            FmtLog.info(LOG, "Create database at %s", db);
            dsg = TDBFactory.createDatasetGraph(db);
        }
        // XXX Database???
        DataSource newDataSource = DataSource.attach(id, "uri", sourceArea, patchesArea);
        dataRegistry.put(id, newDataSource);
        return id ;
    }
    
    /** SourceDescriptor -> JsonObject */
    private static SourceDescriptor fromJsonObject(JsonObject sourceObj) {
        SourceDescriptor descr = new SourceDescriptor();
        descr.idStr = J.getStrOrNull(sourceObj, F_ID) ;
        descr.id = Id.fromString(descr.idStr) ; 
        descr.name = J.getStrOrNull(sourceObj, F_URI) ;
        descr.base = J.getStrOrNull(sourceObj, F_BASE);
        return descr;
    }
    
    /** JsonObject -> SourceDescriptor */
    private static JsonObject toJsonObj(SourceDescriptor descr) {
        String x = descr.idStr;
        if ( x == null && descr.id != null )
            x = descr.id.asString();
        JsonBuilder builder = JsonBuilder.create() ;
        builder.startObject();
        set(builder, F_ID, x);
        set(builder, F_URI, descr.name);
        set(builder, F_BASE, descr.base);
        builder.finishObject();
        return builder.build().getAsObject();
    }

    /** SourceDescriptor -> JsonObject */
    private static void set(JsonBuilder builder, String field, String value) {
        if ( value != null )
            builder.key(field).value(value);
    }
}
